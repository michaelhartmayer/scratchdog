import fs from 'fs';
import path from 'path';

const SPEC_DIR = 'specifications';
const OUTPUT_FILE = 'SPEC.md';

function generateSpec() {
  console.log('Generating SPEC.md...');

  if (!fs.existsSync(SPEC_DIR)) {
    console.error(`Error: Directory ${SPEC_DIR} not found.`);
    process.exit(1);
  }

  const files = fs
    .readdirSync(SPEC_DIR)
    .filter((f) => f.endsWith('.spec.md'))
    .sort();

  if (files.length === 0) {
    console.warn('No .spec.md files found.');
    return;
  }

  let fullContent = '# Project Specifications\n\n';

  // Table of Contents Section
  fullContent += '## Table of Contents\n\n';
  fullContent += '<table width="100%">\n';

  const sections = [];

  for (const file of files) {
    const content = fs.readFileSync(path.join(SPEC_DIR, file), 'utf8');
    const lines = content.split('\n');
    let title = file;

    // Extract first H1 header as title
    for (const line of lines) {
      if (line.startsWith('# ')) {
        title = line.replace('# ', '').trim();
        break;
      }
    }

    const anchorId = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    sections.push({ title, file, anchorId, content: lines });

    fullContent += `  <tr>\n    <td align="left"><a href="#${anchorId}">${title}</a></td>\n    <td align="right"><code>${file}</code></td>\n  </tr>\n`;
  }

  fullContent += '</table>\n\n---\n\n';

  // Content processing
  for (const section of sections) {
    fullContent += `<a name="${section.anchorId}"></a>\n\n`;

    for (const line of section.content) {
      const trimmed = line.trim();

      // Handle empty lines
      if (!trimmed) {
        fullContent += '\n';
        continue;
      }

      // Handle Headers
      if (line.startsWith('#')) {
        // Offset headers by one level except main title
        if (line.startsWith('# ')) {
          fullContent += `## ${line.substring(2)}  \n`;
        } else {
          fullContent += `#${line}  \n`;
        }
        continue;
      }

      // Handle custom numbering lists: match "1.", "1.1.", etc.
      // We prefix with '* ' to force GitHub list rendering which handles nested indentation correctly.
      const listMatch = line.match(/^(\s*)(\d+(?:\.\d+)*\.?)\s+(.*)$/);
      if (listMatch) {
        const indent = listMatch[1];
        const numbering = listMatch[2];
        const text = listMatch[3];

        // GitHub needs 2 or 4 spaces persistent indent for nesting.
        // Our source uses 4 spaces.
        fullContent += `${indent}* ${numbering} ${text}  \n`;
      } else {
        // Regular line
        fullContent += `${line}  \n`;
      }
    }

    fullContent += '\n---\n\n';
  }

  fullContent += '> [!NOTE]\n';
  fullContent += `> This file is autogenerated by \`scripts/generate-spec.js\` from files in the \`${SPEC_DIR}\` directory.\n`;

  fs.writeFileSync(OUTPUT_FILE, fullContent);
  console.log(`Successfully generated ${OUTPUT_FILE}`);
}

generateSpec();
